# 指针强化，字符串
## 数组元素输出的问题
对于字符可以一次性输出数组中的字符，但是对于数值类型的数组，只能利用for循环逐个输出,原因是字符串后有“\0”结束标识  
```
char a[] = "abcd";       // 定义一个字符类型的数组，并进行初始化
int b[]={2, 3, 4, 1, 9}  // 定义一个int型的数组，并进行初始化;  
int i;
printf("%s", a);         // 一次性输出整个字符数组中的所有字符
for(i=0; i<5; i++)       // 利用for循环对int数组中的数字进行逐个输出
    printf("%d ", b[i]);
```
## 指针易错点
1 写内存时，一定要确保内存可写  
```
char *buf = "fwejiofgh";//文字常量区，内存不可改
buf[2] = '1';//err

char buf2[] = "dehoiefho";//可改
buf[3] = '3';//ok
```
分析上述代码，因为指针buf指向全局区的内存常量区，是不可改的因此会出错，而buf2是将全局区的字符串拷贝到栈区，可以进行修改  
2 指针变量的大小  
即sizeof(指针)在32位系统下占4个字节，在64位系统下占8个字节  
不同类型的指针，例如int，char是指针所指向的内存空间的类型和大小，与指针本身的大小无关  
3 不允许向NULL和非法地址拷贝内存  
```
char *p = NULL;
strcpy(p,"111");//err
```
4 指针可以不断的改变指向  
## 指针存在的最大意义：间接赋值
下列程序，如果想通过形参改变实参的值，必须地址传递  
```
int get1()
{
  a = 10;
  return a；
}

void get2(int a)
{
  a = 22;
}

void get2(int *p)
{
  *p = 33;
}

int main(void)
{
  int b = get1();//输出b为10
  
  get2(b);//输出b依然为10
  
  //如果想通过形参改变实参的值，必须地址传递  
  get3(&b);
  
  return 0;
}
```
## 其他知识点
1 主调函数和被调函数：  
```
main()
{
    fun();
}
```
主调函数可以把堆区、栈区、全局区内存地址传给被调函数  
被调函数只能返回堆区、全局区数据  
（通过内存四区画图就可以分析出来）  
## 字符串
1 字符串的输出：  
```
char a[] = "abcd";       
printf("%s", a);      //输出结果为abcd
```
```
char a[] = {'a','b','c','d'};
printf("%s", a);      //输出结果为乱码，原因是不指定长度，没有0结束符
```
将上述语句进行修改：  
```
//方法一
char a[100] = {'a','b','c','d'};  //指定长度，后面没有赋值的元素，自动补0,但是不能越界
```
```
//方法二
char a[] = {'a','b','c','d'，'\0'};
```
strlen:测字符串长度，不包含数字0，字符‘\0’  
sizeof:测数组长度，包括数字0，字符‘\0’  
2 数组法和指针法操作字符串  
```
char buf[] = "abdhcgf";
int i = 0;
int n = strlen(buf);
```
```
//方式1
for (i=0;i<n;i++)
{
    printf("%c",buf[i]);
}
```
```
//方式2
char *p = NULL;
p = buf;   //指针指向数组，数组名字=数组首元素地址=数组首地址
for (i=0;i<n;i++)
{
    printf("%c",p[i]);   //把指针当做数组来用
}
```
```
//方式3
for (i=0;i<n;i++)
{
    printf("%c",*(p+i));   //操作指针所指向的地址，然后将所指向地址的内存数据输出
}
```
```
//方式4
for (i=0;i<n;i++)
{
    printf("%c",*(buf+i));   
}
```
将上述语句整理总结一下：  
```
printf("%c",buf[i]);
printf("%c",p[i]);    //最常用
printf("%c",*(p+i));
printf("%c",*(buf+i));
```

```
//*p++与（*p）++
#include <stdio.h>
void main()
{
    int x=3;
    int *p,*q;
    p=&x,q=&x;
    
    printf("%d\n",*p++);     //3,先取出*p的值，再使p加1,给p加1，相当于让p指向了x所在地址的下一个位置，而对于x则是没有任何影响
    printf("%d\n",(*q)++);   //3,当输出*q之后，再给*q即x自加1，所以x就变为4 
    printf("%d\n",x);        //4
}
```
上述程序中的第二个结果3，为何先输出3，再自加1呢，道理和i++与++i一样，i++是先用再加，++i是先加再用，可以用下列两段简短的代码进行验证  
```
int i=0;
printf("%d", ++i);  //输出为1
```
```
int i=0;
printf("%d", i++);  //输出为0
```
3 项目开发中常用的字符串应用模型  













